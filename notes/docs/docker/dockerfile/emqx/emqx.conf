# https://docs.emqx.com/zh/emqx/v5.7.1/hocon/
# https://docs.emqx.com/en/emqx/v5.0/configuration/configuration-manual.html
node.cookie = "c6cbfa5b9470c69f0dac5d7548044bb1"
node.data_dir = "data"

cluster.name = "emqxcl"
cluster.discovery_strategy = "manual"

dashboard.listeners.http.bind = 18083

## console log
log.console_handler.enable = true
log.console_handler.formatter = "json"
log.console_handler.level = "error"
log.console_handler.time_offset = "system"
log.console_handler.timestamp_format = "rfc3339"

## api key
api_key.bootstrap_file = "/opt/emqx/etc/bootstrap"

## dashboard user
dashboard.default_username = "future"
dashboard.default_password = "!QAZ2wsx"

authorization {
  deny_action = ignore
  no_match = allow
  sources = [
    {
      type = file
      enable = true
      path = "etc/acl.conf"
    }
  ]
}

telemetry {enable = false}
## WebHook 配置
actions {
  http {
    clientconnected {
      connector = clientconnected
      description = ""
      enable = true
      parameters {
        headers {
          accept = "application/json"
          cache-control = no-cache
          connection = keep-alive
          content-type = "application/json"
          keep-alive = "timeout=5"
        }
        max_retries = 2
        method = post
      }
      resource_opts {
        health_check_interval = 15s
        inflight_window = 100
        max_buffer_bytes = 256MB
        query_mode = async
        request_ttl = 45s
        worker_pool_size = 16
      }
      tags = []
    }
    clientdisconnected {
      connector = clientdisconnected
      description = ""
      enable = true
      parameters {
        headers {
          accept = "application/json"
          cache-control = no-cache
          connection = keep-alive
          content-type = "application/json"
          keep-alive = "timeout=5"
        }
        max_retries = 2
        method = post
      }
      resource_opts {
        health_check_interval = 15s
        inflight_window = 100
        max_buffer_bytes = 256MB
        query_mode = async
        request_ttl = 45s
        worker_pool_size = 16
      }
      tags = []
    }
    published {
      connector = published
      enable = true
      parameters {
        headers {
          accept = "application/json"
          cache-control = no-cache
          connection = keep-alive
          content-type = "application/json"
          keep-alive = "timeout=5"
        }
        max_retries = 2
        method = post
      }
      resource_opts {
        health_check_interval = 15s
        inflight_window = 100
        max_buffer_bytes = 256MB
        query_mode = async
        request_ttl = 45s
        worker_pool_size = 16
      }
      tags = []
    }
    subscribed {
      connector = subscribed
      description = ""
      enable = true
      parameters {
        headers {
          accept = "application/json"
          cache-control = no-cache
          connection = keep-alive
          content-type = "application/json"
          keep-alive = "timeout=5"
        }
        max_retries = 2
        method = post
      }
      resource_opts {
        health_check_interval = 15s
        inflight_window = 100
        max_buffer_bytes = 256MB
        query_mode = async
        request_ttl = 45s
        worker_pool_size = 16
      }
      tags = []
    }
    unsubscribed {
      connector = unsubscribed
      description = ""
      enable = true
      parameters {
        headers {
          accept = "application/json"
          cache-control = no-cache
          connection = keep-alive
          content-type = "application/json"
          keep-alive = "timeout=5"
        }
        max_retries = 2
        method = post
      }
      resource_opts {
        health_check_interval = 15s
        inflight_window = 100
        max_buffer_bytes = 256MB
        query_mode = async
        request_ttl = 45s
        worker_pool_size = 16
      }
      tags = []
    }
  }
}
connectors {
  http {
    clientconnected {
      connect_timeout = 15s
      description = ""
      enable = true
      enable_pipelining = 100
      headers {content-type = "application/json"}
      pool_size = 8
      pool_type = random
      resource_opts {
        health_check_interval = 15s
        start_after_created = true
        start_timeout = 5s
      }
      ssl {
        ciphers = []
        depth = 10
        enable = false
        hibernate_after = 5s
        log_level = notice
        reuse_sessions = true
        secure_renegotiate = true
        verify = verify_none
        versions = [tlsv1.3, tlsv1.2]
      }
      tags = []
      url = "http://192.168.11.41:3101/chatroom/webhook"
    }
    clientdisconnected {
      connect_timeout = 15s
      description = ""
      enable = true
      enable_pipelining = 100
      headers {content-type = "application/json"}
      pool_size = 8
      pool_type = random
      resource_opts {
        health_check_interval = 15s
        start_after_created = true
        start_timeout = 5s
      }
      ssl {
        ciphers = []
        depth = 10
        enable = false
        hibernate_after = 5s
        log_level = notice
        reuse_sessions = true
        secure_renegotiate = true
        verify = verify_none
        versions = [tlsv1.3, tlsv1.2]
      }
      tags = []
      url = "http://192.168.11.41:3101/chatroom/webhook"
    }
    published {
      connect_timeout = 15s
      enable = true
      enable_pipelining = 100
      headers {content-type = "application/json"}
      pool_size = 8
      pool_type = random
      resource_opts {
        health_check_interval = 15s
        start_after_created = true
        start_timeout = 5s
      }
      ssl {
        ciphers = []
        depth = 10
        enable = false
        hibernate_after = 5s
        log_level = notice
        reuse_sessions = true
        secure_renegotiate = true
        verify = verify_none
        versions = [tlsv1.3, tlsv1.2]
      }
      tags = []
      url = "http://192.168.11.41:3101/chatroom/webhook"
    }
    subscribed {
      connect_timeout = 15s
      description = ""
      enable = true
      enable_pipelining = 100
      headers {content-type = "application/json"}
      pool_size = 8
      pool_type = random
      resource_opts {
        health_check_interval = 15s
        start_after_created = true
        start_timeout = 5s
      }
      ssl {
        ciphers = []
        depth = 10
        enable = false
        hibernate_after = 5s
        log_level = notice
        reuse_sessions = true
        secure_renegotiate = true
        verify = verify_none
        versions = [tlsv1.3, tlsv1.2]
      }
      tags = []
      url = "http://192.168.11.41:3101/chatroom/webhook"
    }
    unsubscribed {
      connect_timeout = 15s
      description = ""
      enable = true
      enable_pipelining = 100
      headers {content-type = "application/json"}
      pool_size = 8
      pool_type = random
      resource_opts {
        health_check_interval = 15s
        start_after_created = true
        start_timeout = 5s
      }
      ssl {
        ciphers = []
        depth = 10
        enable = false
        hibernate_after = 5s
        log_level = notice
        reuse_sessions = true
        secure_renegotiate = true
        verify = verify_none
        versions = [tlsv1.3, tlsv1.2]
      }
      tags = []
      url = "http://192.168.11.41:3101/chatroom/webhook"
    }
  }
}
mqtt {
  await_rel_timeout = 300s
  exclusive_subscription = false
  idle_timeout = 15s
  ignore_loop_deliver = false
  keepalive_multiplier = 1.5
  max_awaiting_rel = 100
  max_clientid_len = 65535
  max_inflight = 32
  max_mqueue_len = 1000
  max_packet_size = 1MB
  max_qos_allowed = 1
  max_subscriptions = infinity
  max_topic_alias = 65535
  max_topic_levels = 128
  mqueue_default_priority = lowest
  mqueue_priorities = disabled
  mqueue_store_qos0 = true
  peer_cert_as_clientid = disabled
  peer_cert_as_username = disabled
  response_information = ""
  retain_available = true
  retry_interval = 30s
  server_keepalive = disabled
  session_expiry_interval = 2h
  shared_subscription = true
  shared_subscription_strategy = round_robin
  strict_mode = false
  upgrade_qos = false
  use_username_as_clientid = false
  wildcard_subscription = true
}
rule_engine {
  ignore_sys_message = true
  jq_function_default_timeout = 10s
  rules {
    clientconnected {
      actions = ["http:clientconnected"]
      description = ""
      enable = true
      name = ""
      sql = "SELECT\n  *\nFROM\n  \"$events/client_connected\""
    }
    clientdisconnected {
      actions = ["http:clientdisconnected"]
      description = ""
      enable = true
      name = ""
      sql = "SELECT\n  *\nFROM\n  \"$events/client_disconnected\""
    }
    published {
      actions = ["http:published"]
      description = ""
      enable = true
      name = ""
      sql = "SELECT\n  *\nFROM\n  \"/+/aics/#\""
    }
    subscribed {
      actions = ["http:subscribed"]
      description = ""
      enable = true
      name = ""
      sql = "SELECT\n  *\nFROM\n  \"$events/session_subscribed\""
    }
    unsubscribed {
      actions = ["http:unsubscribed"]
      description = ""
      enable = true
      name = ""
      sql = "SELECT\n  *\nFROM\n  \"$events/session_unsubscribed\""
    }
  }
}